Welcome to this comprehensive repository! This collection of experiments in this repository is designed to help students gain practical experience in implementing, analyzing, and comparing fundamental algorithms essential to computer science and software development. Through hands-on experimentation, this assignment deepens understanding of algorithm design and the nuances of performance optimization.

Each experiment highlights key algorithmic techniques—from sorting and searching to dynamic programming and graph traversal. This lab assignment is ideal for students aiming to build a strong foundation in the principles of efficient algorithmic problem-solving.

Experiments Overview
1. Insertion in Binary Search Tree (BST)
This experiment implements both iterative and recursive methods for inserting elements in a Binary Search Tree (BST). Comparing these methods helps students understand how recursion depth and stack overhead impact efficiency, especially in large datasets.

2. Merge Sort vs. Quick Sort
Here, the divide-and-conquer sorting algorithms—Merge Sort and Quick Sort—are implemented and compared on the same dataset. This experiment enables students to analyze sorting efficiency and understand the practical differences between stable sorting in Merge Sort and in-place partitioning in Quick Sort.

3. Strassen’s Method vs. Traditional Matrix Multiplication
Matrix multiplication is a fundamental operation in many fields, and this experiment compares Strassen’s optimized method to the traditional approach. This highlights how Strassen’s method reduces time complexity for large matrices, providing students with insights into computational efficiency.

4. Activity Selection Problem (Greedy Approach)
The classic Activity Selection problem is solved using a Greedy approach, demonstrating the method’s efficacy in optimization problems where locally optimal choices lead to a globally optimal solution. This experiment gives students practical exposure to the principles behind greedy algorithms.

5. Matrix Chain Multiplication (Dynamic Programming)
This experiment tackles Matrix Chain Multiplication using dynamic programming, illustrating how DP optimizes complex problems by breaking them into overlapping subproblems. Students observe how parenthesis positioning in matrix multiplication affects computation time, showcasing optimal substructure and memoization.

6. Dijkstra vs. Bellman-Ford (Single Source Shortest Path)
Both Dijkstra’s and Bellman-Ford algorithms are applied to find the shortest path from a single source. Dijkstra’s algorithm works efficiently for graphs without negative weights, while Bellman-Ford accommodates graphs with negative weights. This experiment emphasizes choosing the right algorithm based on graph structure.

7. 0/1 Knapsack Problem (Greedy vs. Dynamic Programming)
Through the 0/1 Knapsack problem, students compare the limitations of the Greedy approach with the accuracy of the Dynamic Programming approach. This experiment demonstrates the advantages of DP when choices affect future decisions in optimization problems.

8. Sum of Subset
The Sum of Subset experiment requires finding subsets that add up to a specific sum, illustrating subset-sum solutions. This problem is highly relevant in fields like cryptography, data partitioning, and load balancing, providing students with real-world applications of algorithmic design.

9. 0/1 Knapsack Problem: Backtracking vs. Branch & Bound
Backtracking and Branch & Bound are implemented for the 0/1 Knapsack problem, with a Dynamic Programming approach for comparison. This experiment deepens understanding of advanced problem-solving strategies that handle exponential solution spaces efficiently.

10. String Matching: Rabin-Karp, Knuth-Morris-Pratt, and Naive Algorithms
This experiment implements three string-matching algorithms—Naive, Rabin-Karp, and Knuth-Morris-Pratt (KMP)—to highlight string search efficiency. Comparing these algorithms enables students to appreciate optimized string search techniques in applications like search engines and bioinformatics.

This repository serves as a comprehensive guide through the most important algorithmic approaches in computer science, helping students gain practical skills and understanding of algorithm efficiency. Through coding and analysis, this lab assignment builds a solid foundation in the design and application of algorithms. Happy learning and exploring!
